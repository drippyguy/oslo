{"version":3,"sources":["../../src/crypto/random.ts"],"sourcesContent":["import { bytesToInteger } from \"../bytes.js\";\n\nexport function random(): number {\n\tconst buffer = new ArrayBuffer(8);\n\tconst bytes = crypto.getRandomValues(new Uint8Array(buffer));\n\n\t// sets the exponent value (11 bits) to 01111111111 (1023)\n\t// since the bias is 1023 (2 * (11 - 1) - 1), 1023 - 1023 = 0\n\t// 2^0 * (1 + [52 bit number between 0-1]) = number between 1-2\n\tbytes[0] = 63;\n\tbytes[1] = bytes[1]! | 240;\n\n\treturn new DataView(buffer).getFloat64(0) - 1;\n}\n\nexport function generateRandomInteger(max: number): number {\n\tif (max < 0 || !Number.isInteger(max)) {\n\t\tthrow new Error(\"Argument 'max' must be an integer greater than or equal to 0\");\n\t}\n\tconst bitLength = (max - 1).toString(2).length;\n\tconst shift = bitLength % 8;\n\tconst bytes = new Uint8Array(Math.ceil(bitLength / 8));\n\n\tcrypto.getRandomValues(bytes);\n\n\t// This zeroes bits that can be ignored to increase the chance `result` < `max`.\n\t// For example, if `max` can be represented with 10 bits, the leading 6 bits of the random 16 bits (2 bytes) can be ignored.\n\tif (shift !== 0) {\n\t\tbytes[0] &= (1 << shift) - 1;\n\t}\n\tlet result = bytesToInteger(bytes);\n\twhile (result >= max) {\n\t\tcrypto.getRandomValues(bytes);\n\t\tif (shift !== 0) {\n\t\t\tbytes[0] &= (1 << shift) - 1;\n\t\t}\n\t\tresult = bytesToInteger(bytes);\n\t}\n\treturn result;\n}\n\nexport function generateRandomString(length: number, alphabet: string): string {\n\tlet result = \"\";\n\tfor (let i = 0; i < length; i++) {\n\t\tresult += alphabet[generateRandomInteger(alphabet.length)];\n\t}\n\treturn result;\n}\n\ntype AlphabetPattern = \"a-z\" | \"A-Z\" | \"0-9\" | \"-\" | \"_\";\n\nexport function alphabet(...patterns: AlphabetPattern[]): string {\n\tconst patternSet = new Set<AlphabetPattern>(patterns);\n\tlet result = \"\";\n\tfor (const pattern of patternSet) {\n\t\tif (pattern === \"a-z\") {\n\t\t\tresult += \"abcdefghijklmnopqrstuvwxyz\";\n\t\t} else if (pattern === \"A-Z\") {\n\t\t\tresult += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\t\t} else if (pattern === \"0-9\") {\n\t\t\tresult += \"0123456789\";\n\t\t} else {\n\t\t\tresult += pattern;\n\t\t}\n\t}\n\treturn result;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAA+B;AAExB,SAAS,SAAiB;AAChC,QAAM,SAAS,IAAI,YAAY,CAAC;AAChC,QAAM,QAAQ,OAAO,gBAAgB,IAAI,WAAW,MAAM,CAAC;AAK3D,QAAM,CAAC,IAAI;AACX,QAAM,CAAC,IAAI,MAAM,CAAC,IAAK;AAEvB,SAAO,IAAI,SAAS,MAAM,EAAE,WAAW,CAAC,IAAI;AAC7C;AAEO,SAAS,sBAAsB,KAAqB;AAC1D,MAAI,MAAM,KAAK,CAAC,OAAO,UAAU,GAAG,GAAG;AACtC,UAAM,IAAI,MAAM,8DAA8D;AAAA,EAC/E;AACA,QAAM,aAAa,MAAM,GAAG,SAAS,CAAC,EAAE;AACxC,QAAM,QAAQ,YAAY;AAC1B,QAAM,QAAQ,IAAI,WAAW,KAAK,KAAK,YAAY,CAAC,CAAC;AAErD,SAAO,gBAAgB,KAAK;AAI5B,MAAI,UAAU,GAAG;AAChB,UAAM,CAAC,MAAM,KAAK,SAAS;AAAA,EAC5B;AACA,MAAI,aAAS,6BAAe,KAAK;AACjC,SAAO,UAAU,KAAK;AACrB,WAAO,gBAAgB,KAAK;AAC5B,QAAI,UAAU,GAAG;AAChB,YAAM,CAAC,MAAM,KAAK,SAAS;AAAA,IAC5B;AACA,iBAAS,6BAAe,KAAK;AAAA,EAC9B;AACA,SAAO;AACR;AAEO,SAAS,qBAAqB,QAAgBA,WAA0B;AAC9E,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,cAAUA,UAAS,sBAAsBA,UAAS,MAAM,CAAC;AAAA,EAC1D;AACA,SAAO;AACR;AAIO,SAAS,YAAY,UAAqC;AAChE,QAAM,aAAa,IAAI,IAAqB,QAAQ;AACpD,MAAI,SAAS;AACb,aAAW,WAAW,YAAY;AACjC,QAAI,YAAY,OAAO;AACtB,gBAAU;AAAA,IACX,WAAW,YAAY,OAAO;AAC7B,gBAAU;AAAA,IACX,WAAW,YAAY,OAAO;AAC7B,gBAAU;AAAA,IACX,OAAO;AACN,gBAAU;AAAA,IACX;AAAA,EACD;AACA,SAAO;AACR;","names":["alphabet"]}