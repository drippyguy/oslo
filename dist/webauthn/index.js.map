{"version":3,"sources":["../../src/webauthn/index.ts"],"sourcesContent":["import { base64url } from \"../encoding/index.js\";\nimport { compareBytes } from \"../bytes.js\";\nimport { ECDSA, RSASSAPKCS1v1_5 } from \"../crypto/index.js\";\n\nimport type { TypedArray } from \"../index.js\";\n\nexport interface AttestationResponse {\n\tclientDataJSON: ArrayBuffer | TypedArray;\n\tauthenticatorData: ArrayBuffer | TypedArray;\n}\n\nexport interface AssertionResponse {\n\tclientDataJSON: ArrayBuffer | TypedArray;\n\tauthenticatorData: ArrayBuffer | TypedArray;\n\tsignature: ArrayBuffer | TypedArray;\n}\n\nexport class WebAuthnController {\n\tprivate originURL: URL;\n\tconstructor(origin: string) {\n\t\tthis.originURL = new URL(origin);\n\t}\n\n\tpublic async validateAttestationResponse(\n\t\tresponse: AttestationResponse,\n\t\tchallenge: ArrayBuffer | TypedArray\n\t): Promise<void> {\n\t\tconst validClientDataJSON = this.verifyClientDataJSON(\n\t\t\t\"webauthn.create\",\n\t\t\tresponse.clientDataJSON,\n\t\t\tchallenge\n\t\t);\n\t\tif (!validClientDataJSON) {\n\t\t\tthrow new Error(\"Failed to validate client data JSON\");\n\t\t}\n\n\t\tconst validAuthenticatorData = await this.verifyAuthenticatorData(response.authenticatorData);\n\t\tif (!validAuthenticatorData) {\n\t\t\tthrow new Error(\"Failed to validate authenticator data\");\n\t\t}\n\t}\n\n\tpublic async validateAssertionResponse(\n\t\talgorithm: \"ES256\" | \"RS256\",\n\t\tpublicKey: ArrayBuffer | TypedArray,\n\t\tresponse: AssertionResponse,\n\t\tchallenge: ArrayBuffer | TypedArray\n\t): Promise<void> {\n\t\tconst validClientDataJSON = this.verifyClientDataJSON(\n\t\t\t\"webauthn.get\",\n\t\t\tresponse.clientDataJSON,\n\t\t\tchallenge\n\t\t);\n\t\tif (!validClientDataJSON) {\n\t\t\tthrow new Error(\"Failed to validate client data JSON\");\n\t\t}\n\n\t\tconst validAuthenticatorData = await this.verifyAuthenticatorData(response.authenticatorData);\n\t\tif (!validAuthenticatorData) {\n\t\t\tthrow new Error(\"Failed to validate authenticator data\");\n\t\t}\n\n\t\tif (algorithm === \"ES256\") {\n\t\t\tconst signature = convertDERSignatureToECDSASignature(response.signature);\n\t\t\tconst hash = await crypto.subtle.digest(\"SHA-256\", response.clientDataJSON);\n\t\t\tconst data = concatenateBuffer(response.authenticatorData, hash);\n\t\t\tconst es256 = new ECDSA(\"SHA-256\", \"P-256\");\n\t\t\tconst validSignature = await es256.verify(publicKey, signature, data);\n\t\t\tif (!validSignature) {\n\t\t\t\tthrow new Error(\"Failed to validate signature\");\n\t\t\t}\n\t\t} else if (algorithm === \"RS256\") {\n\t\t\tconst signature = convertDERSignatureToECDSASignature(response.signature);\n\t\t\tconst hash = await crypto.subtle.digest(\"SHA-256\", response.clientDataJSON);\n\t\t\tconst data = concatenateBuffer(response.authenticatorData, hash);\n\t\t\tconst rs256 = new RSASSAPKCS1v1_5(\"SHA-256\");\n\t\t\tconst validSignature = await rs256.verify(publicKey, signature, data);\n\t\t\tif (!validSignature) {\n\t\t\t\tthrow new Error(\"Failed to validate signature\");\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError(`Unknown algorithm: ${algorithm}`);\n\t\t}\n\t}\n\n\tprivate verifyClientDataJSON(\n\t\ttype: \"webauthn.create\" | \"webauthn.get\",\n\t\tclientDataJSON: ArrayBuffer | TypedArray,\n\t\tchallenge: ArrayBuffer | TypedArray\n\t): boolean {\n\t\tconst clientData: unknown = JSON.parse(new TextDecoder().decode(clientDataJSON));\n\t\tif (!clientData || typeof clientData !== \"object\") {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(\"type\" in clientData) || clientData.type !== type) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(\"challenge\" in clientData) || typeof clientData.challenge !== \"string\") {\n\t\t\treturn false;\n\t\t}\n\t\tconst clientDataChallengeBuffer = base64url.decode(clientData.challenge, {\n\t\t\tstrict: false,\n\t\t});\n\t\tif (!compareBytes(clientDataChallengeBuffer, challenge)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(\"origin\" in clientData) || clientData.origin !== this.originURL.origin) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate async verifyAuthenticatorData(authenticatorData: ArrayBuffer): Promise<boolean> {\n\t\tconst authData = new Uint8Array(authenticatorData);\n\t\tif (authData.byteLength < 37) {\n\t\t\treturn false;\n\t\t}\n\t\tconst rpIdHash = authData.slice(0, 32);\n\t\tconst rpIdData = new TextEncoder().encode(this.originURL.hostname);\n\t\tconst expectedRpIdHash = await crypto.subtle.digest(\"SHA-256\", rpIdData);\n\t\t// compare buffer\n\t\tif (!compareBytes(rpIdHash, expectedRpIdHash)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst flagsBits = authData[32]!.toString(2);\n\t\tif (flagsBits.charAt(flagsBits.length - 1) !== \"1\") {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n\nfunction convertDERSignatureToECDSASignature(DERSignature: ArrayBuffer): ArrayBuffer {\n\tconst signatureBytes = new Uint8Array(DERSignature);\n\n\tconst rStart = 4;\n\tconst rLength = signatureBytes[3];\n\tconst rEnd = rStart + rLength!;\n\tconst DEREncodedR = signatureBytes.slice(rStart, rEnd);\n\t// DER encoded 32 bytes integers can have leading 0x00s or be smaller than 32 bytes\n\tconst r = decodeDERInteger(DEREncodedR, 32);\n\n\tconst sStart = rEnd + 2;\n\tconst sEnd = signatureBytes.byteLength;\n\tconst DEREncodedS = signatureBytes.slice(sStart, sEnd);\n\t// repeat the process\n\tconst s = decodeDERInteger(DEREncodedS, 32);\n\n\tconst ECDSASignature = new Uint8Array([...r, ...s]);\n\treturn ECDSASignature.buffer;\n}\n\nfunction decodeDERInteger(integerBytes: Uint8Array, expectedLength: number): Uint8Array {\n\tif (integerBytes.byteLength === expectedLength) return integerBytes;\n\tif (integerBytes.byteLength < expectedLength) {\n\t\treturn concatenateUint8Array(\n\t\t\t// add leading 0x00s if smaller than expected length\n\t\t\tnew Uint8Array(expectedLength - integerBytes.byteLength).fill(0),\n\t\t\tintegerBytes\n\t\t);\n\t}\n\t// remove leading 0x00s if larger then expected length\n\treturn integerBytes.slice(-32);\n}\n\nfunction concatenateBuffer(\n\tbuffer1: ArrayBuffer | TypedArray,\n\tbuffer2: ArrayBuffer | TypedArray\n): ArrayBuffer {\n\treturn concatenateUint8Array(new Uint8Array(buffer1), new Uint8Array(buffer2)).buffer;\n}\n\nfunction concatenateUint8Array(bytes1: Uint8Array, bytes2: Uint8Array): Uint8Array {\n\tconst result = new Uint8Array(bytes1.byteLength + bytes2.byteLength);\n\tresult.set(new Uint8Array(bytes1), 0);\n\tresult.set(new Uint8Array(bytes2), bytes1.byteLength);\n\treturn result;\n}\n"],"mappings":"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","names":[]}