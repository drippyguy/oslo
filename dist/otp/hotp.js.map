{"version":3,"sources":["../../src/otp/hotp.ts"],"sourcesContent":["import { binaryToInteger, byteToBinary, bytesToBinary } from \"../bytes.js\";\nimport { HMAC } from \"../crypto/hmac.js\";\n\nimport type { TypedArray } from \"../index.js\";\n\nexport async function generateHOTP(\n\tkey: ArrayBuffer | TypedArray,\n\tcounter: number,\n\tdigits: number = 6\n): Promise<string> {\n\tif (digits > 8) {\n\t\tthrow new TypeError(\"Digits must be 8 or smaller\");\n\t}\n\tconst counterBytes = intTo8Bytes(counter);\n\tconst HS = await new HMAC(\"SHA-1\").sign(key, counterBytes);\n\tconst SBites = truncate(new Uint8Array(HS));\n\tconst SNum = binaryToInteger(SBites);\n\tconst D = SNum % 10 ** digits;\n\treturn D.toString().padStart(digits, \"0\");\n}\n\nfunction truncate(data: Uint8Array): string {\n\tconst offset = binaryToInteger(byteToBinary(data[data.byteLength - 1]!).slice(4));\n\treturn bytesToBinary(data).slice(offset * 8 + 1, (offset + 4) * 8);\n}\n\nfunction intTo8Bytes(int: number): Uint8Array {\n\tconst result = new Uint8Array(8);\n\tconst bits = int.toString(2).padStart(8 * 8, \"0\");\n\tfor (let i = 0; i < 8; i++) {\n\t\tresult[i] = binaryToInteger(bits.slice(i * 8, (i + 1) * 8));\n\t}\n\treturn result;\n}\n"],"mappings":"AAAA,SAAS,iBAAiB,cAAc,qBAAqB;AAC7D,SAAS,YAAY;AAIrB,eAAsB,aACrB,KACA,SACA,SAAiB,GACC;AAClB,MAAI,SAAS,GAAG;AACf,UAAM,IAAI,UAAU,6BAA6B;AAAA,EAClD;AACA,QAAM,eAAe,YAAY,OAAO;AACxC,QAAM,KAAK,MAAM,IAAI,KAAK,OAAO,EAAE,KAAK,KAAK,YAAY;AACzD,QAAM,SAAS,SAAS,IAAI,WAAW,EAAE,CAAC;AAC1C,QAAM,OAAO,gBAAgB,MAAM;AACnC,QAAM,IAAI,OAAO,MAAM;AACvB,SAAO,EAAE,SAAS,EAAE,SAAS,QAAQ,GAAG;AACzC;AAEA,SAAS,SAAS,MAA0B;AAC3C,QAAM,SAAS,gBAAgB,aAAa,KAAK,KAAK,aAAa,CAAC,CAAE,EAAE,MAAM,CAAC,CAAC;AAChF,SAAO,cAAc,IAAI,EAAE,MAAM,SAAS,IAAI,IAAI,SAAS,KAAK,CAAC;AAClE;AAEA,SAAS,YAAY,KAAyB;AAC7C,QAAM,SAAS,IAAI,WAAW,CAAC;AAC/B,QAAM,OAAO,IAAI,SAAS,CAAC,EAAE,SAAS,IAAI,GAAG,GAAG;AAChD,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC3B,WAAO,CAAC,IAAI,gBAAgB,KAAK,MAAM,IAAI,IAAI,IAAI,KAAK,CAAC,CAAC;AAAA,EAC3D;AACA,SAAO;AACR;","names":[]}